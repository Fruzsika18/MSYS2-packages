From 3eb6e90d7fb3a91f5ae82a0ebff4b18cedf690c7 Mon Sep 17 00:00:00 2001
From: Takashi Yano <takashi.yano@nifty.ne.jp>
Date: Mon, 28 Feb 2022 20:25:09 +0900
Subject: [PATCH 031/N] Cygwin: pty: Isolate CTRL_C_EVENTs between ptys.

- With this patch, unique invisible consoles are created for each pty
  to isolate CTRL_C_EVENTs between ptys. This is necessary by Ctrl-C
  handling in fhandler_termios::process_sigs() for non-cygwin apps
  started in pty if the pseudo console is disabled.

Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
---
 winsup/cygwin/fhandler_termios.cc |  6 ++----
 winsup/cygwin/fhandler_tty.cc     | 17 +++++++++++++++++
 winsup/cygwin/tty.cc              |  2 ++
 3 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/winsup/cygwin/fhandler_termios.cc b/winsup/cygwin/fhandler_termios.cc
index 028210d..f83770e 100644
--- a/winsup/cygwin/fhandler_termios.cc
+++ b/winsup/cygwin/fhandler_termios.cc
@@ -368,8 +368,7 @@ fhandler_termios::process_sigs (char c, tty* ttyp, fhandler_termios *fh)
 	    {
 	      FreeConsole ();
 	      AttachConsole (p->dwProcessId);
-	      if (::cygheap->ctty && ::cygheap->ctty->is_console ())
-		init_console_handler (true);
+	      init_console_handler (true);
 	    }
 	  if (fh && p == myself && being_debugged ())
 	    { /* Avoid deadlock in gdb on console. */
@@ -393,8 +392,7 @@ fhandler_termios::process_sigs (char c, tty* ttyp, fhandler_termios *fh)
 	    {
 	      FreeConsole ();
 	      AttachConsole (resume_pid);
-	      if (::cygheap->ctty && ::cygheap->ctty->is_console ())
-		init_console_handler (true);
+	      init_console_handler (true);
 	    }
 	  need_discard_input = true;
 	}
diff --git a/winsup/cygwin/fhandler_tty.cc b/winsup/cygwin/fhandler_tty.cc
index f82d1e9..de5209f 100644
--- a/winsup/cygwin/fhandler_tty.cc
+++ b/winsup/cygwin/fhandler_tty.cc
@@ -547,6 +547,7 @@ fhandler_pty_master::accept_input ()
 	  cp_to = GetConsoleCP ();
 	  FreeConsole ();
 	  AttachConsole (resume_pid);
+	  init_console_handler (true);
 	  release_attach_mutex ();
 	}
       else
@@ -967,6 +968,12 @@ fhandler_pty_slave::open (int flags, mode_t)
        this behaviour, protection based on attach_mutex does
        not take effect. */
     get_ttyp ()->need_invisible_console = true;
+  else if (_major (myself->ctty) != DEV_CONS_MAJOR
+	   && (!get_ttyp ()->invisible_console_pid
+	       || !pinfo (get_ttyp ()->invisible_console_pid)))
+    /* Create a new invisible console for each pty to isolate
+       CTRL_C_EVENTs between ptys. */
+    get_ttyp ()->need_invisible_console = true;
   else
     fhandler_console::need_invisible ();
 
@@ -1027,6 +1034,7 @@ fhandler_pty_slave::close ()
   fhandler_pty_common::close ();
   if (!ForceCloseHandle (output_mutex))
     termios_printf ("CloseHandle (output_mutex<%p>), %E", output_mutex);
+  get_ttyp ()->invisible_console_pid = 0;
   return 0;
 }
 
@@ -1232,12 +1240,14 @@ fhandler_pty_slave::reset_switch_to_pcon (void)
 				       0, TRUE, DUPLICATE_SAME_ACCESS);
 		      FreeConsole ();
 		      AttachConsole (get_ttyp ()->pcon_pid);
+		      init_console_handler (true);
 		      WaitForSingleObject (input_mutex, mutex_timeout);
 		      transfer_input (tty::to_cyg, h_pcon_in, get_ttyp (),
 				      input_available_event);
 		      ReleaseMutex (input_mutex);
 		      FreeConsole ();
 		      AttachConsole (resume_pid);
+		      init_console_handler (true);
 		      CloseHandle (h_pcon_in);
 		    }
 		  CloseHandle (pcon_owner);
@@ -2839,6 +2849,7 @@ fhandler_pty_master::pty_master_fwd_thread (const master_fwd_thread_param_t *p)
 	  cp_from = GetConsoleOutputCP ();
 	  FreeConsole ();
 	  AttachConsole (resume_pid);
+	  init_console_handler (true);
 	  release_attach_mutex ();
 	}
       else
@@ -3261,6 +3272,7 @@ fhandler_pty_slave::setup_pseudoconsole (bool nopcon)
       CloseHandle (pcon_owner);
       FreeConsole ();
       AttachConsole (get_ttyp ()->pcon_pid);
+      init_console_handler (true);
       goto skip_create;
     }
 
@@ -3384,6 +3396,7 @@ fhandler_pty_slave::setup_pseudoconsole (bool nopcon)
       /* Attach to pseudo console */
       FreeConsole ();
       AttachConsole (pi.dwProcessId);
+      init_console_handler (true);
 
       /* Terminate helper process */
       SetEvent (goodbye);
@@ -3573,6 +3586,7 @@ fhandler_pty_slave::close_pseudoconsole (tty *ttyp, DWORD force_switch_to)
 		}
 	      else
 		AttachConsole (ATTACH_PARENT_PROCESS);
+	      init_console_handler (true);
 	    }
 	  else
 	    { /* Close pseudo console */
@@ -3585,6 +3599,7 @@ fhandler_pty_slave::close_pseudoconsole (tty *ttyp, DWORD force_switch_to)
 		}
 	      else
 		AttachConsole (ATTACH_PARENT_PROCESS);
+	      init_console_handler (true);
 	      /* Reconstruct pseudo console handler container here for close */
 	      HPCON_INTERNAL *hp =
 		(HPCON_INTERNAL *) HeapAlloc (GetProcessHeap (), 0,
@@ -3613,6 +3628,7 @@ fhandler_pty_slave::close_pseudoconsole (tty *ttyp, DWORD force_switch_to)
 	    }
 	  else
 	    AttachConsole (ATTACH_PARENT_PROCESS);
+	  init_console_handler (true);
 	}
     }
   else if (pcon_pid_self (ttyp->pcon_pid))
@@ -3779,6 +3795,7 @@ fhandler_pty_slave::create_invisible_console ()
       /* Detach from console device and create new invisible console. */
       FreeConsole();
       fhandler_console::need_invisible (true);
+      init_console_handler (true);
       get_ttyp ()->need_invisible_console = false;
       get_ttyp ()->invisible_console_pid = myself->pid;
     }
diff --git a/winsup/cygwin/tty.cc b/winsup/cygwin/tty.cc
index bc5c96e..a988088 100644
--- a/winsup/cygwin/tty.cc
+++ b/winsup/cygwin/tty.cc
@@ -344,6 +344,7 @@ tty_min::setpgid (int pid)
 	      CloseHandle (pcon_owner);
 	      FreeConsole ();
 	      AttachConsole (ttyp->pcon_pid);
+	      init_console_handler (true);
 	      attach_restore = true;
 	    }
 	  WaitForSingleObject (ptys->input_mutex, mutex_timeout);
@@ -361,6 +362,7 @@ tty_min::setpgid (int pid)
 		}
 	      else
 		AttachConsole (ATTACH_PARENT_PROCESS);
+	      init_console_handler (true);
 	    }
 	}
       ReleaseMutex (ptys->pcon_mutex);
-- 
2.9.0

