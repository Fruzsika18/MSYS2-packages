From d8b0ff56735a8e3f4b7e38805cdafdab385d27ec Mon Sep 17 00:00:00 2001
From: Takashi Yano <takashi.yano@nifty.ne.jp>
Date: Tue, 22 Mar 2022 22:49:46 +0900
Subject: [PATCH 057/N] Cygwin: pipe: Avoid deadlock for non-cygwin writer.

- As mentioned in commit message of the commit b531d6b0, if multiple
  writers including non-cygwin app exist, the non-cygwin app cannot
  detect pipe closure on the read side when the pipe is created by
  system account or the the pipe creator is running as service.
  This is because query_hdl which is held in write side also is a
  read end of the pipe, so the pipe is still alive for the non-cygwin
  app even after the reader is closed.

  To avoid this problem, this patch lets all processes in the same
  process group close query_hdl using newly introduced internal signal
  __SIGNONCYGCHLD when non-cygwin app is started.

  Addresses: https://cygwin.com/pipermail/cygwin/2022-March/251097.html

Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
---
 winsup/cygwin/fhandler.h       | 20 ++++++++++++++++++++
 winsup/cygwin/fhandler_pipe.cc | 23 +++++++++++++++++++++++
 winsup/cygwin/release/3.3.5    |  5 +++++
 winsup/cygwin/sigproc.cc       | 10 ++++++++++
 winsup/cygwin/sigproc.h        |  3 ++-
 winsup/cygwin/spawn.cc         | 18 +++++++++++++++++-
 6 files changed, 77 insertions(+), 2 deletions(-)

diff --git a/winsup/cygwin/fhandler.h b/winsup/cygwin/fhandler.h
index 3fe1274..291aa5b 100644
--- a/winsup/cygwin/fhandler.h
+++ b/winsup/cygwin/fhandler.h
@@ -1194,6 +1194,7 @@ private:
   HANDLE hdl_cnt_mtx;
   HANDLE query_hdl_proc;
   HANDLE query_hdl_value;
+  HANDLE query_hdl_close_req_evt;
   uint64_t pipename_key;
   DWORD pipename_pid;
   LONG pipename_id;
@@ -1255,9 +1256,28 @@ public:
 	CloseHandle (query_hdl);
 	query_hdl = NULL;
       }
+    if (query_hdl_close_req_evt)
+      {
+	CloseHandle (query_hdl_close_req_evt);
+	query_hdl_close_req_evt = NULL;
+      }
   }
   bool reader_closed ();
   HANDLE temporary_query_hdl ();
+  bool need_close_query_hdl ()
+    {
+      return query_hdl_close_req_evt ?
+	IsEventSignalled (query_hdl_close_req_evt) : false;
+    }
+  bool request_close_query_hdl ()
+    {
+      if (query_hdl_close_req_evt)
+	{
+	  SetEvent (query_hdl_close_req_evt);
+	  return true;
+	}
+      return false;
+    }
 };
 
 #define CYGWIN_FIFO_PIPE_NAME_LEN     47
diff --git a/winsup/cygwin/fhandler_pipe.cc b/winsup/cygwin/fhandler_pipe.cc
index 71635cc..82c1ed3 100644
--- a/winsup/cygwin/fhandler_pipe.cc
+++ b/winsup/cygwin/fhandler_pipe.cc
@@ -599,6 +599,8 @@ fhandler_pipe::fixup_after_fork (HANDLE parent)
     fork_fixup (parent, select_sem, "select_sem");
   if (query_hdl)
     fork_fixup (parent, query_hdl, "query_hdl");
+  if (query_hdl_close_req_evt)
+    fork_fixup (parent, query_hdl_close_req_evt, "query_hdl_close_req_evt");
 
   fhandler_base::fixup_after_fork (parent);
   ReleaseMutex (hdl_cnt_mtx);
@@ -649,6 +651,16 @@ fhandler_pipe::dup (fhandler_base *child, int flags)
       ftp->close ();
       res = -1;
     }
+  else if (query_hdl_close_req_evt &&
+	   !DuplicateHandle (GetCurrentProcess (), query_hdl_close_req_evt,
+			     GetCurrentProcess (),
+			     &ftp->query_hdl_close_req_evt,
+			     0, !(flags & O_CLOEXEC), DUPLICATE_SAME_ACCESS))
+    {
+      __seterrno ();
+      ftp->close ();
+      res = -1;
+    }
   ReleaseMutex (hdl_cnt_mtx);
 
   debug_printf ("res %d", res);
@@ -668,6 +680,8 @@ fhandler_pipe::close ()
   WaitForSingleObject (hdl_cnt_mtx, INFINITE);
   if (query_hdl)
     CloseHandle (query_hdl);
+  if (query_hdl_close_req_evt)
+    CloseHandle (query_hdl_close_req_evt);
   int ret = fhandler_base::close ();
   ReleaseMutex (hdl_cnt_mtx);
   CloseHandle (hdl_cnt_mtx);
@@ -901,9 +915,18 @@ fhandler_pipe::create (fhandler_pipe *fhs[2], unsigned psize, int mode)
 			0, sa->bInheritHandle, DUPLICATE_SAME_ACCESS))
     goto err_close_hdl_cnt_mtx0;
 
+  if (fhs[1]->query_hdl)
+    {
+      fhs[1]->query_hdl_close_req_evt = CreateEvent (sa, TRUE, FALSE, NULL);
+      if (!fhs[1]->query_hdl_close_req_evt)
+	goto err_close_hdl_cnt_mtx1;
+    }
+
   res = 0;
   goto out;
 
+err_close_hdl_cnt_mtx1:
+  CloseHandle (fhs[1]->hdl_cnt_mtx);
 err_close_hdl_cnt_mtx0:
   CloseHandle (fhs[0]->hdl_cnt_mtx);
 err_close_query_hdl:
diff --git a/winsup/cygwin/release/3.3.5 b/winsup/cygwin/release/3.3.5
index 9d44c1b..f0a8340 100644
--- a/winsup/cygwin/release/3.3.5
+++ b/winsup/cygwin/release/3.3.5
@@ -46,3 +46,8 @@ Bug Fixes
 
 - Fix crash on pty master close in Windows 7.
   Addresses: https://cygwin.com/pipermail/cygwin/2022-March/251162.html
+
+- Avoid deadlock of non-cygwin pipe writer which occurs when the other
+  cygwin pipe writers exist if the pipe is created by system account
+  or the pipe creator is running as service.
+  Addresses: https://cygwin.com/pipermail/cygwin/2022-March/251097.html
diff --git a/winsup/cygwin/sigproc.cc b/winsup/cygwin/sigproc.cc
index dc77af6..e923f4e 100644
--- a/winsup/cygwin/sigproc.cc
+++ b/winsup/cygwin/sigproc.cc
@@ -1477,6 +1477,16 @@ wait_sig (VOID *)
 		clearwait = true;
 	    }
 	  break;
+	case __SIGNONCYGCHLD:
+	  cygheap_fdenum cfd (false);
+	  while (cfd.next () >= 0)
+	    if (cfd->get_dev () == FH_PIPEW)
+	      {
+		fhandler_pipe *pipe = (fhandler_pipe *)(fhandler_base *) cfd;
+		if (pipe->need_close_query_hdl ())
+		  pipe->close_query_handle ();
+	      }
+	  break;
 	}
       if (clearwait && !have_execed)
 	proc_subproc (PROC_CLEARWAIT, 0);
diff --git a/winsup/cygwin/sigproc.h b/winsup/cygwin/sigproc.h
index 2a3d248..cfde4bd 100644
--- a/winsup/cygwin/sigproc.h
+++ b/winsup/cygwin/sigproc.h
@@ -22,7 +22,8 @@ enum
   __SIGHOLD	    = -(_NSIG + 7),
   __SIGNOHOLD	    = -(_NSIG + 8),
   __SIGSETPGRP	    = -(_NSIG + 9),
-  __SIGTHREADEXIT   = -(_NSIG + 10)
+  __SIGTHREADEXIT   = -(_NSIG + 10),
+  __SIGNONCYGCHLD   = -(_NSIG + 12),
 };
 #endif
 
diff --git a/winsup/cygwin/spawn.cc b/winsup/cygwin/spawn.cc
index fb3d09d..4004571 100644
--- a/winsup/cygwin/spawn.cc
+++ b/winsup/cygwin/spawn.cc
@@ -28,6 +28,7 @@ details. */
 #include "tls_pbuf.h"
 #include "winf.h"
 #include "ntdll.h"
+#include "shared_info.h"
 
 static const suffix_info exe_suffixes[] =
 {
@@ -631,6 +632,7 @@ child_info_spawn::worker (const char *prog_arg, const char *const *argv,
 
       if (!iscygwin ())
 	{
+	  bool need_send_sig = false;
 	  int fd;
 	  cygheap_fdenum cfd (false);
 	  while ((fd = cfd.next ()) >= 0)
@@ -645,14 +647,28 @@ child_info_spawn::worker (const char *prog_arg, const char *const *argv,
 		     && (fd == fileno_stdout || fd == fileno_stderr))
 	      {
 		fhandler_pipe *pipe = (fhandler_pipe *)(fhandler_base *) cfd;
-		pipe->close_query_handle ();
 		pipe->set_pipe_non_blocking (false);
+		if (pipe->request_close_query_hdl ())
+		  need_send_sig = true;
 	      }
 	    else if (cfd->get_dev () == FH_PIPER && fd == fileno_stdin)
 	      {
 		fhandler_pipe *pipe = (fhandler_pipe *)(fhandler_base *) cfd;
 		pipe->set_pipe_non_blocking (false);
 	      }
+
+	  if (need_send_sig)
+	    {
+	      tty_min dummy_tty;
+	      dummy_tty.ntty = (fh_devices) myself->ctty;
+	      dummy_tty.pgid = myself->pgid;
+	      tty_min *t = cygwin_shared->tty.get_cttyp ();
+	      if (!t) /* If tty is not allocated, use dummy_tty instead. */
+		t = &dummy_tty;
+	      /* Emit __SIGNONCYGCHLD to let all processes in the
+		 process group close query_hdl. */
+	      t->kill_pgrp (__SIGNONCYGCHLD);
+	    }
 	}
 
       bool stdin_is_ptys = false;
-- 
2.9.0

