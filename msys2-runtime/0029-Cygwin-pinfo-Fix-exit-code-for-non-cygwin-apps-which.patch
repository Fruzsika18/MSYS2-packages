From ecd07c0c540a882c907b7c1374e8c320cb9d5d7f Mon Sep 17 00:00:00 2001
From: Takashi Yano <takashi.yano@nifty.ne.jp>
Date: Sat, 26 Feb 2022 15:13:13 +0900
Subject: [PATCH 029/N] Cygwin: pinfo: Fix exit code for non-cygwin apps
 which reads console.

- The recent commit "Cygwin: pinfo: Fix exit code when non-cygwin app
  exits by Ctrl-C." did not fix enough the issue. If a non-cygwin app
  is reading the console, it will not return STATUS_CONTROL_C_EXIT
  even if it is terminated by Ctrl-C. As a result, the previous patch
  does not take effect.
  This patch solves this issue by setting sigExeced to SIGINT in
  ctrl_c_handler(). In addition, sigExeced will be cleared if the app
  does not terminated within predetermined time period. The reason is
  that the app does not seem to be terminated by the signal sigExeced.

Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
---
 winsup/cygwin/exceptions.cc |  6 +++++-
 winsup/cygwin/globals.cc    |  2 +-
 winsup/cygwin/spawn.cc      | 15 ++++++++++++++-
 3 files changed, 20 insertions(+), 3 deletions(-)

diff --git a/winsup/cygwin/exceptions.cc b/winsup/cygwin/exceptions.cc
index 6e0b862..070e52e 100644
--- a/winsup/cygwin/exceptions.cc
+++ b/winsup/cygwin/exceptions.cc
@@ -1139,7 +1139,11 @@ ctrl_c_handler (DWORD type)
     }
 
   if (ch_spawn.set_saw_ctrl_c ())
-    return TRUE;
+    {
+      if (myself->process_state & PID_NOTCYGWIN)
+	sigExeced = SIGINT;
+      return TRUE;
+    }
 
   /* We're only the process group leader when we have a valid pinfo structure.
      If we don't have one, then the parent "stub" will handle the signal. */
diff --git a/winsup/cygwin/globals.cc b/winsup/cygwin/globals.cc
index 48fb312..5687a1e 100644
--- a/winsup/cygwin/globals.cc
+++ b/winsup/cygwin/globals.cc
@@ -20,7 +20,7 @@ HANDLE NO_COPY hProcImpToken;
 HANDLE my_wr_proc_pipe;
 HMODULE NO_COPY cygwin_hmodule;
 HMODULE NO_COPY hntdll;
-int NO_COPY sigExeced;
+LONG NO_COPY sigExeced;
 WCHAR windows_system_directory[MAX_PATH];
 UINT windows_system_directory_length;
 WCHAR system_wow64_directory[MAX_PATH];
diff --git a/winsup/cygwin/spawn.cc b/winsup/cygwin/spawn.cc
index 3647580..3b54309 100644
--- a/winsup/cygwin/spawn.cc
+++ b/winsup/cygwin/spawn.cc
@@ -953,7 +953,15 @@ child_info_spawn::worker (const char *prog_arg, const char *const *argv,
 	  if (sem)
 	    __posix_spawn_sem_release (sem, 0);
 	  if (ptys_need_cleanup || cons_need_cleanup)
-	    WaitForSingleObject (pi.hProcess, INFINITE);
+	    {
+	      LONG prev_sigExeced = sigExeced;
+	      while (WaitForSingleObject (pi.hProcess, 100) == WAIT_TIMEOUT)
+		/* If child process does not exit in predetermined time
+		   period, the process does not seem to be terminated by
+		   the signal sigExeced. Therefore, clear sigExeced here. */
+		prev_sigExeced =
+		  InterlockedCompareExchange (&sigExeced, 0, prev_sigExeced);
+	    }
 	  if (ptys_need_cleanup)
 	    {
 	      fhandler_pty_slave::cleanup_for_non_cygwin_app (&ptys_handle_set,
@@ -966,6 +974,11 @@ child_info_spawn::worker (const char *prog_arg, const char *const *argv,
 	      fhandler_console::cleanup_for_non_cygwin_app (&cons_handle_set);
 	      fhandler_console::close_handle_set (&cons_handle_set);
 	    }
+	  /* Make sure that ctrl_c_handler() is not on going. Calling
+	     init_console_handler(false) locks until returning from
+	     ctrl_c_handler(). This insures that setting sigExeced
+	     on Ctrl-C key has been completed. */
+	  init_console_handler (false);
 	  myself.exit (EXITCODE_NOSET);
 	  break;
 	case _P_WAIT:
-- 
2.9.0

