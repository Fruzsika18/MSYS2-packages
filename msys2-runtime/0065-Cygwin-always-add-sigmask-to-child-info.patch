From e1cf8361da2275b02e6e30b72bffe29863e0c904 Mon Sep 17 00:00:00 2001
From: Corinna Vinschen <corinna@vinschen.de>
Date: Tue, 3 May 2022 15:16:18 +0200
Subject: [PATCH 065/N] Cygwin: always add sigmask to child info

Even after fork, we might need the parent sigmask without having
access to the real _main_tls. There's a short time at process startup,
when _main_tls points to the system-allocated stack, but wait_sig is
already running. If we can't lock _main_tls, because find_tls can't
find it yet, we now access the parent's sigmask via child_info.

Signed-off-by: Corinna Vinschen <corinna@vinschen.de>
Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
---
 winsup/cygwin/child_info.h |  5 +++--
 winsup/cygwin/dcrt0.cc     |  2 +-
 winsup/cygwin/sigproc.cc   | 18 ++++++++++++++----
 3 files changed, 18 insertions(+), 7 deletions(-)

diff --git a/winsup/cygwin/child_info.h b/winsup/cygwin/child_info.h
index 505eaef..d98308b 100644
--- a/winsup/cygwin/child_info.h
+++ b/winsup/cygwin/child_info.h
@@ -37,7 +37,7 @@ enum child_status
 #define EXEC_MAGIC_SIZE sizeof(child_info)
 
 /* Change this value if you get a message indicating that it is out-of-sync. */
-#define CURR_CHILD_INFO_MAGIC 0xecc930b9U
+#define CURR_CHILD_INFO_MAGIC 0xacbf4682U
 
 #include "pinfo.h"
 struct cchildren
@@ -71,6 +71,8 @@ public:
   unsigned fhandler_union_cb;
   DWORD exit_code;	// process exit code
   static int retry_count;// retry count;
+  sigset_t sigmask;
+
   child_info (unsigned, child_info_types, bool);
   child_info (): subproc_ready (NULL), parent (NULL) {}
   ~child_info ();
@@ -130,7 +132,6 @@ public:
   int envc;
   char **envp;
   HANDLE myself_pinfo;
-  sigset_t sigmask;
   int nchildren;
   cchildren children[0];
   static cygheap_exec_info *alloc ();
diff --git a/winsup/cygwin/dcrt0.cc b/winsup/cygwin/dcrt0.cc
index 31dfd6f..28b5146 100644
--- a/winsup/cygwin/dcrt0.cc
+++ b/winsup/cygwin/dcrt0.cc
@@ -849,7 +849,7 @@ dll_crt0_1 (void *)
   _my_tls.incyg++;
   /* Inherit "parent" exec'ed process sigmask */
   if (spawn_info && !in_forkee)
-    _my_tls.sigmask = spawn_info->moreinfo->sigmask;
+    _my_tls.sigmask = spawn_info->sigmask;
 
   if (dynamically_loaded)
     sigproc_init ();
diff --git a/winsup/cygwin/sigproc.cc b/winsup/cygwin/sigproc.cc
index e923f4e..b5143e8 100644
--- a/winsup/cygwin/sigproc.cc
+++ b/winsup/cygwin/sigproc.cc
@@ -820,7 +820,7 @@ child_info::child_info (unsigned in_cb, child_info_types chtype,
   cb (in_cb), intro (PROC_MAGIC_GENERIC), magic (CHILD_INFO_MAGIC),
   type (chtype), cygheap (::cygheap), cygheap_max (::cygheap_max),
   flag (0), retry (child_info::retry_count), rd_proc_pipe (NULL),
-  wr_proc_pipe (NULL)
+  wr_proc_pipe (NULL), sigmask (_my_tls.sigmask)
 {
   /* It appears that when running under WOW64 on Vista 64, the first DWORD
      value in the datastructure lpReserved2 is pointing to (msv_count in
@@ -922,7 +922,6 @@ cygheap_exec_info::alloc ()
 					 sizeof (cygheap_exec_info)
 					 + (chld_procs.count ()
 					    * sizeof (children[0])));
-  res->sigmask = _my_tls.sigmask;
   return res;
 }
 
@@ -1373,9 +1372,20 @@ wait_sig (VOID *)
       threadlist_t *tl_entry;
       if (!pack.mask)
 	{
+	  /* There's a short time at process startup of a forked process,
+	     when _main_tls points to the system-allocated stack, not to
+	     the parent thread. In that case find_tls fails, and we fetch
+	     the sigmask from the child_info passed from the parent. */
 	  tl_entry = cygheap->find_tls (_main_tls);
-	  dummy_mask = _main_tls->sigmask;
-	  cygheap->unlock_tls (tl_entry);
+	  if (tl_entry)
+	    {
+	      dummy_mask = _main_tls->sigmask;
+	      cygheap->unlock_tls (tl_entry);
+	    }
+	  else if (child_proc_info)
+	    dummy_mask = child_proc_info->sigmask;
+	  else
+	    dummy_mask = 0;
 	  pack.mask = &dummy_mask;
 	}
 
-- 
2.9.0

